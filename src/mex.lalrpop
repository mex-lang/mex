use crate::lexer::{Token, LexicalError};
use crate::ast;

grammar<'input>(source: &'input ast::Source, global: &'input ast::RefScope<'input>);

pub Package: ast::RefScope<'input> = {
    <p: PackageRoot> => {
        ast::Scope::add_space(global.clone(), p)
    },
    <p: PackageNessted> => {
        //let r = ast::Scope::new_package(source.get_name());
        ast::Scope::add_space(global.clone(), p);
        global.clone()
    },
    <root: Package> <p: PackageNessted> => {
        ast::Scope::add_space(root.clone(), p);
        root
    },
    //! => ast::Scope::Error(<>).into()
}

pub PackageItems: Vec<ast::RefScope<'input>> = {
    <p: PackageNessted> => {
        vec![p]
    },
    <mut items: PackageItems> <p: PackageNessted> => {
        items.push(p);
        items
    }
}

pub PackageNessted: ast::RefScope<'input> = {
     "package" <name: Name> "{" "}" => ast::Scope::new_package(name, vec![]),
     "package" <name: Name> "{" <items: PackageItems> "}" => ast::Scope::new_package(name, items),
     <m: Model> => m,
     ! => ast::Scope::Error(<>).into()
}

pub PackageRoot: ast::RefScope<'input> = {
     "package" <name: Name> ";" => ast::Scope::new_package(name, vec![])
}

pub Model: ast::RefScope<'input> = {
    "model" <name: Name> "{" "}" => ast::Scope::new_model(name)
}

pub Name: &'input str = {
    <name: "id"> => name
}

extern {
  type Location = usize;
  type Error = LexicalError;

  enum Token<'input> {
    "package" => Token::KeywordPackage,
    "model" => Token::KeywordModel,
    "enum" => Token::KeywordEnum,
    "fragment" => Token::KeywordFragment,
    "scalar" => Token::KeywordScalar,

    "id" => Token::Identifier(<&'input str>),
    "int" => Token::Integer(<i64>),

    "(" => Token::LParen,
    ")" => Token::RParen,
    "{" => Token::LBracket,
    "}" => Token::RBracket,
    "<" => Token::Lees,
    ">" => Token::Greater,

    "?" => Token::Question,
    "=" => Token::Assign,
    ";" => Token::Semicolon,
    ":" => Token::Colon,
    "..." => Token::Spread,

    "error" => Token::Error(<LexicalError>),
  }
}

// use lalrpop_util::{ErrorRecovery, ParseError};
//    <err: "error"> => {
//        let error = ErrorRecovery {
//            error: ParseError::User {
//                error: LexicalError::InvalidToken,
//            },
//            dropped_tokens: Vec::new(), // or specify the dropped tokens
//        };
//        errors.push(error);
//        Box::new(ast::Scope::Error)
//    },