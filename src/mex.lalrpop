use crate::lexer::{Token, LexicalError};
use crate::ast;

grammar<'input>(source: &'input ast::Source, global: &'input ast::RefScope<'input>);

pub Package: ast::RefScope<'input> = {
    <p: PackageRoot> => {
        ast::Scope::add_space(global.clone(), p)
    },
    <p: PackageNessted> => {
        //let r = ast::Scope::new_package(source.get_name());
        ast::Scope::add_space(global.clone(), p);
        global.clone()
    },
    <root: Package> <p: PackageNessted> => {
        ast::Scope::add_space(root.clone(), p);
        root
    },
    //! => ast::Scope::Error(<>).into()
}

pub PackageItems: Vec<ast::RefScope<'input>> = {
    <p: PackageNessted> => vec![p],
    <mut items: PackageItems> <p: PackageNessted> => {
        items.push(p);
        items
    }
}

pub PackageNessted: ast::RefScope<'input> = {
     "package" <name: Name> "{" "}" => ast::Scope::new_package(name, vec![]),
     "package" <name: Name> "{" <items: PackageItems> "}" => ast::Scope::new_package(name, items),
     "fragment" <f: Fragment> => ast::Scope::new_model(f),
     "model" <m: Model> => ast::Scope::new_model(m),
     "enum" <i: Enum> => ast::Scope::new_model(i),
     "scalar" <s: Scalar> => ast::Scope::new_model(s),
     ! => ast::Scope::Error(<>).into()
}

pub PackageRoot: ast::RefScope<'input> = {
     "package" <name: Name> ";" => ast::Scope::new_package(name, vec![])
}

pub Model: ast::ModelDefinition<'input> = {
    <name: Name> "{" "}" =>  ast::ModelDefinition::new_record(name.into(), vec![]),
    <name: Name?> "{" <items: RecordItems> "}" => ast::ModelDefinition::new_record(name.into(), items),
    <name: Name?> "(" <items: TupleItems?> ")" => ast::ModelDefinition::new_tuple(name.into(), items.unwrap_or(vec![])),
}

pub TupleItems: Vec<ast::TupleItem<'input>> = {
    <i: TupleItem> => vec![i],
    <mut items: TupleItems>"," <i: TupleItem> => {
        items.push(i);
        items
    }
}

pub TupleItem: ast::TupleItem<'input> = {
    <t: Name> => {
        ast::TupleItem::new_item(ast::ItemType::Name(t.into()))
    },
    <n: Name> ":" <t: ItemType> => {
        ast::TupleItem::new_named_item(n, t)
    }
}

pub RecordItems: Vec<ast::RecordItem<'input>> = {
    <i: RecordNested> => vec![i],
    <mut items: RecordItems> <i: RecordNested> => {
        items.push(i);
        items
    }
}

pub RecordNested: ast::RecordItem<'input> = {
    <f: RecordField> ","? => f,
    <s: RecordSpred> ","? => s,
}

pub RecordField: ast::RecordItem<'input> = {
    <f: Name> ":" <t: ItemType> => {
        ast::RecordItem::new_item(f, t)
    }
}

pub RecordSpred: ast::RecordItem<'input> = {
    "..." <t: ItemType> => {
        ast::RecordItem::new_spread(t)
    }
}

pub Fragment: ast::ModelDefinition<'input> = {
    <name: Name> "{" <items: RecordItems?> "}" => ast::ModelDefinition::new_fragment(name.into(), items.unwrap_or(vec![])),
}

pub Enum: ast::ModelDefinition<'input> = {
    <name: Name?> "{" <items: EnunItems> "}" => ast::ModelDefinition::new_enum(name.into(), items)
}

pub EnunItems: Vec<ast::EnumItem<'input>> = {
    <i: EnumNested> => vec![i],
    <mut items: EnunItems> <i: EnumNested> => {
        items.push(i);
        items
    }
}

pub EnumNested: ast::EnumItem<'input> = {
    <i: EnunItem> ","? => i,
    <i: EnumTuple> ","? => i,
    <i: EnumRecord> ","? => i,
}

pub EnunItem: ast::EnumItem<'input> = {
    <name: Name> => ast::EnumItem::new_item(name)
}

pub EnumRecord: ast::EnumItem<'input> = {
    <name: Name> "(" "{" <items: RecordItems> "}" ")" => ast::EnumItem::new_record(name.into(), items),
}

pub EnumTuple: ast::EnumItem<'input> = {
    <name: Name> "(" <items: TupleItems?> ")" => ast::EnumItem::new_tuple(name.into(), items.unwrap_or(vec![])),
}

pub Scalar: ast::ModelDefinition<'input> = {
    <name: Name> ";" => ast::ModelDefinition::new_scalar(name.into())
}

pub Name: &'input str = {
    <name: "id"> => name
}

pub ItemType: ast::ItemType<'input> = {
    <name: Name> => ast::ItemType::new_name(name),
    <m: Model> => ast::ItemType::new_inline(m),
    "enum" <i: Enum> => ast::ItemType::new_inline(i),
}

extern {
  type Location = usize;
  type Error = LexicalError;

  enum Token<'input> {
    "package" => Token::KeywordPackage,
    "model" => Token::KeywordModel,
    "enum" => Token::KeywordEnum,
    "fragment" => Token::KeywordFragment,
    "scalar" => Token::KeywordScalar,

    "id" => Token::Identifier(<&'input str>),
    "int" => Token::Integer(<i64>),

    "(" => Token::LParen,
    ")" => Token::RParen,
    "{" => Token::LBracket,
    "}" => Token::RBracket,
    "<" => Token::Lees,
    ">" => Token::Greater,

    "?" => Token::Question,
    "=" => Token::Assign,
    ";" => Token::Semicolon,
    ":" => Token::Colon,
    "," => Token::Comma,
    "..." => Token::Spread,

    "error" => Token::Error(<LexicalError>),
  }
}

// use lalrpop_util::{ErrorRecovery, ParseError};
//    <err: "error"> => {
//        let error = ErrorRecovery {
//            error: ParseError::User {
//                error: LexicalError::InvalidToken,
//            },
//            dropped_tokens: Vec::new(), // or specify the dropped tokens
//        };
//        errors.push(error);
//        Box::new(ast::Scope::Error)
//    },